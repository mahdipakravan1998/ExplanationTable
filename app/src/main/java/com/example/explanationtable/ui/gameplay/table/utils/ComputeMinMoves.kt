package com.example.explanationtable.ui.gameplay.table.utils

/**
 * Represents a state of the board.
 *
 * @property table The current board configuration.
 * @property fixedPositions Set of indices that are fixed (already in their target positions).
 * @property moves Total number of moves performed so far.
 * @property cost The cumulative cost (each move contributes a cost of 1).
 * @property heuristic Estimated number of moves remaining (computed via cycle decomposition).
 * @property parent The previous state that led to the current state.
 * @property lastSwap The last swap move performed (used to avoid immediate reversal).
 */
data class State(
    val table: List<String>,
    val fixedPositions: Set<Int>,
    val moves: Int,
    val cost: Double,
    val heuristic: Double,
    val parent: State? = null,
    val lastSwap: Pair<Int, Int>? = null
) : Comparable<State> {

    /**
     * Compare two states based on their estimated total cost (cost + heuristic).
     */
    override fun compareTo(other: State): Int =
        (cost + heuristic).compareTo(other.cost + other.heuristic)
}

/**
 * Computes an exact cycle-decomposition heuristic for the board.
 *
 * For each cycle among non-fixed indices:
 * - A cycle of length L contributes exactly (L - 1) moves.
 *
 * @param table Current board configuration.
 * @param targetTable Target board configuration.
 * @param fixedPositions Set of indices that are fixed.
 * @param goalMap Map of board element to its target index.
 * @return The heuristic value (lower bound on remaining moves).
 */
fun cycleHeuristic(
    table: List<String>,
    targetTable: List<String>,
    fixedPositions: Set<Int>,
    goalMap: Map<String, Int>
): Double {
    var heuristic = 0.0
    val visited = BooleanArray(table.size)

    // Iterate over each index in the table.
    for (i in table.indices) {
        // Skip fixed or already visited positions.
        if (i in fixedPositions || visited[i]) {
            visited[i] = true
            continue
        }
        // If the element is already at its target, mark as visited.
        if (table[i] == targetTable[i]) {
            visited[i] = true
            continue
        }

        // Trace the cycle starting at index i.
        var cycleLength = 0
        var j = i
        while (!visited[j]) {
            visited[j] = true
            cycleLength++
            // Move to the target position for the current element.
            j = goalMap[table[j]] ?: break
        }
        // A cycle contributes (length - 1) moves if longer than a single element.
        if (cycleLength > 1) {
            heuristic += (cycleLength - 1)
        }
    }
    return heuristic
}

/**
 * Generates macro moves that resolve entire cycles (with length > 2) in one composite move.
 *
 * @param current The current state.
 * @param targetTable The target board configuration.
 * @param goalMap Map from piece to its target index.
 * @return List of new states generated by applying macro moves.
 */
fun generateMacroMoves(
    current: State,
    targetTable: List<String>,
    goalMap: Map<String, Int>
): List<State> {
    val macroMoves = mutableListOf<State>()
    val visitedIndices = BooleanArray(current.table.size)
    val cycles = mutableListOf<List<Int>>()

    // Identify cycles among non-fixed indices.
    for (i in current.table.indices) {
        if (i in current.fixedPositions || visitedIndices[i]) continue

        // If the element is already at its target, mark as visited.
        if (current.table[i] == targetTable[i]) {
            visitedIndices[i] = true
            continue
        }

        val cycle = mutableListOf<Int>()
        var j = i
        while (!visitedIndices[j]) {
            visitedIndices[j] = true
            cycle.add(j)
            j = goalMap[current.table[j]] ?: break
        }
        if (cycle.size > 1) {
            cycles.add(cycle)
        }
    }

    // Create a new state for each cycle longer than 2 (macro move).
    for (cycle in cycles) {
        if (cycle.size > 2) {
            val newTable = current.table.toMutableList()
            val newFixed = current.fixedPositions.toMutableSet()
            // Fix all positions in the cycle.
            for (idx in cycle) {
                newTable[idx] = targetTable[idx]
                newFixed.add(idx)
            }
            val moveCost = (cycle.size - 1).toDouble() // Cost equals (cycle length - 1).
            val newHeuristic = cycleHeuristic(newTable, targetTable, newFixed, goalMap)
            val newState = State(
                table = newTable,
                fixedPositions = newFixed,
                moves = current.moves + (cycle.size - 1),
                cost = current.cost + moveCost,
                heuristic = newHeuristic,
                parent = current,
                lastSwap = null // Macro moves do not have a simple swap.
            )
            macroMoves.add(newState)
        }
    }
    return macroMoves
}

/**
 * Creates a new state by swapping two positions and updating the fixed positions.
 *
 * @param current The current state.
 * @param pos1 The first index to swap.
 * @param pos2 The second index to swap.
 * @param targetTable The target board configuration.
 * @param goalMap Map from board element to its target index.
 * @return A new state after performing the swap.
 */
fun createSwapState(
    current: State,
    pos1: Int,
    pos2: Int,
    targetTable: List<String>,
    goalMap: Map<String, Int>
): State {
    val newTable = current.table.toMutableList()
    // Swap the two elements.
    newTable[pos1] = current.table[pos2]
    newTable[pos2] = current.table[pos1]

    // Update fixed positions: mark positions that now match the target.
    val newFixed = current.fixedPositions.toMutableSet()
    if (newTable[pos1] == targetTable[pos1]) newFixed.add(pos1) else newFixed.remove(pos1)
    if (newTable[pos2] == targetTable[pos2]) newFixed.add(pos2) else newFixed.remove(pos2)

    val moveCost = 1.0
    val newHeuristic = cycleHeuristic(newTable, targetTable, newFixed, goalMap)
    return State(
        table = newTable,
        fixedPositions = newFixed,
        moves = current.moves + 1,
        cost = current.cost + moveCost,
        heuristic = newHeuristic,
        parent = current,
        lastSwap = pos1 to pos2
    )
}

/**
 * Performs the IDA* search (iterative deepening A* using depth-first search) recursively.
 *
 * @param current The current state.
 * @param bound The current cost threshold.
 * @param targetTable The target board configuration.
 * @param goalMap Map from board element to its target index.
 * @param transposition A cache mapping state keys to the best cost found.
 * @return A pair where the first element is the solution state (if found), and the second is the next bound.
 */
private fun idaSearch(
    current: State,
    bound: Double,
    targetTable: List<String>,
    goalMap: Map<String, Int>,
    transposition: MutableMap<String, Double>
): Pair<State?, Double> {
    val f = current.cost + current.heuristic
    if (f > bound) return Pair(null, f)
    if (current.table == targetTable) return Pair(current, bound)

    // Create a unique key for the state using the table and sorted fixed positions.
    val stateKey = current.table.joinToString(",") + "|" + current.fixedPositions.sorted().joinToString(",")
    // Prune if a better or equal cost for this state has already been found.
    if (stateKey in transposition && transposition[stateKey]!! <= current.cost) {
        return Pair(null, Double.POSITIVE_INFINITY)
    }
    transposition[stateKey] = current.cost

    var minThreshold = Double.POSITIVE_INFINITY
    val successors = mutableListOf<State>()

    // Add macro moves first.
    successors.addAll(generateMacroMoves(current, targetTable, goalMap))

    // Generate standard pairwise swap moves for unfixed positions.
    val unfixedPositions = (current.table.indices).filter { it !in current.fixedPositions }
    for (i in unfixedPositions.indices) {
        for (j in (i + 1) until unfixedPositions.size) {
            val pos1 = unfixedPositions[i]
            val pos2 = unfixedPositions[j]
            // Avoid immediately reversing the previous swap.
            if (current.lastSwap?.let { pos1 == it.second && pos2 == it.first } == true) continue
            successors.add(createSwapState(current, pos1, pos2, targetTable, goalMap))
        }
    }

    // Sort successors by their estimated total cost (cost + heuristic).
    successors.sortBy { it.cost + it.heuristic }

    // Recurse on each successor.
    for (succ in successors) {
        val (solution, tempBound) = idaSearch(succ, bound, targetTable, goalMap, transposition)
        if (solution != null) return Pair(solution, bound)
        if (tempBound < minThreshold) minThreshold = tempBound
    }
    return Pair(null, minThreshold)
}

/**
 * Solves the board using an IDA* search with a cycle-based heuristic and a transposition table.
 *
 * @param initialTable The starting board configuration.
 * @param targetTable The target board configuration.
 * @param gridWidth Grid width (must evenly divide the table size).
 * @return The minimal number of moves required or -1 if unsolvable.
 * @throws IllegalArgumentException if grid dimensions are invalid.
 */
fun solveWithAStar(
    initialTable: List<String>,
    targetTable: List<String>,
    gridWidth: Int = 3
): Int {
    // Validate grid dimensions.
    if (gridWidth <= 0 || initialTable.size % gridWidth != 0) {
        throw IllegalArgumentException("gridWidth must divide the table size evenly")
    }
    // Check for trivial solution or unsolvable cases.
    if (initialTable == targetTable) return 0
    if (!initialTable.containsAll(targetTable) || !targetTable.containsAll(initialTable)) return -1

    // Precompute mapping from each board piece to its target index (assumes unique elements).
    val goalMap = targetTable.withIndex().associate { it.value to it.index }

    // Initialize the state with the cycle-based heuristic.
    val initialHeuristic = cycleHeuristic(initialTable, targetTable, emptySet(), goalMap)
    val initialState = State(initialTable, emptySet(), 0, 0.0, initialHeuristic)

    var bound = initialState.cost + initialState.heuristic
    val transposition = mutableMapOf<String, Double>()

    // Iterative deepening loop.
    while (true) {
        transposition.clear()
        val (solution, newBound) = idaSearch(initialState, bound, targetTable, goalMap, transposition)
        if (solution != null) {
            val path = reconstructPath(solution)
            printSolutionPath(path)
            return solution.moves
        }
        if (newBound == Double.POSITIVE_INFINITY) break
        bound = newBound
    }
    return -1
}

/**
 * Reconstructs the solution path by following parent pointers from the final state back to the initial state.
 *
 * @param state The final (solution) state.
 * @return A list of states representing the solution path from the initial state to the final state.
 */
fun reconstructPath(state: State): List<State> {
    val path = mutableListOf<State>()
    var current: State? = state
    while (current != null) {
        path.add(current)
        current = current.parent
    }
    return path.reversed()
}

/**
 * Prints the solution path in a human-readable format.
 *
 * For each move, the function shows the board before and after the move,
 * indicates the swap or macro move details, and lists the fixed positions.
 *
 * @param path The sequence of states from initial to solution.
 */
fun printSolutionPath(path: List<State>) {
    for (i in 0 until path.size - 1) {
        val current = path[i]
        val next = path[i + 1]
        println("Step ${i + 1}:")
        println("Before move:")
        println(current.table.joinToString(" "))

        // Determine positions that changed.
        val diffPositions = current.table.indices.filter { current.table[it] != next.table[it] }
        if (diffPositions.size == 2) {
            println("Swapping positions ${diffPositions[0]} and ${diffPositions[1]}")
        } else {
            println("Macro move fixing positions: ${diffPositions.joinToString(", ")}")
        }
        println("After move:")
        println(next.table.joinToString(" "))
        println("Fixed positions: ${next.fixedPositions}")
        println("------")
    }
    println("Final state:")
    println(path.last().table.joinToString(" "))
    println("Total moves: ${path.last().moves}")
}
